(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{479:function(v,_,t){"use strict";t.r(_);var r=t(1),a=Object(r.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"👋-软考中级系统架构师"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#👋-软考中级系统架构师"}},[v._v("#")]),v._v(" 👋 软考中级系统架构师")]),v._v(" "),_("blockquote",[_("p",[v._v("备战 中级软件设计师")])]),v._v(" "),_("div",{staticClass:"custom-block right"},[_("p",[v._v("来自 "),_("a",{attrs:{href:"http://sapphire611.github.io",target:"_blank",rel:"noopener noreferrer"}},[v._v("Sapphire611"),_("OutboundLink")],1)])]),v._v(" "),_("hr"),v._v(" "),_("h2",{attrs:{id:"程序设计语言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#程序设计语言"}},[v._v("#")]),v._v(" 程序设计语言")]),v._v(" "),_("p",[_("a",{attrs:{href:"https://www.bilibili.com/video/BV1tL411c7gi",target:"_blank",rel:"noopener noreferrer"}},[v._v("「软件设计师」 上午题 #2 程序设计语言"),_("OutboundLink")],1)]),v._v(" "),_("h3",{attrs:{id:"编译程序和解释程序"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#编译程序和解释程序"}},[v._v("#")]),v._v(" 编译程序和解释程序")]),v._v(" "),_("ul",[_("li",[v._v("解释器:翻译源程序时不生成独立的目标程序")])]),v._v(" "),_("blockquote",[_("p",[v._v("解释程序和源程序要参与到程序的运行过程中")])]),v._v(" "),_("ul",[_("li",[v._v("编译器:翻译时将源程序翻译成独立保存的目标程序")])]),v._v(" "),_("blockquote",[_("p",[v._v("机器上运行的是与源程序等价的目标程序，源程序和编译程序都不再参与目标程序的运行过程")])]),v._v(" "),_("h3",{attrs:{id:"程序设计语言基本成分"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#程序设计语言基本成分"}},[v._v("#")]),v._v(" 程序设计语言基本成分")]),v._v(" "),_("ul",[_("li",[v._v("基本控制接口： 顺序、选择和重复（循环接口）")])]),v._v(" "),_("h4",{attrs:{id:"短路计算"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#短路计算"}},[v._v("#")]),v._v(" 短路计算")]),v._v(" "),_("blockquote",[_("p",[v._v("判断遵循从左往右看")])]),v._v(" "),_("ul",[_("li",[_("code",[v._v("&&")]),v._v(" 有一个 false 就为 false")]),v._v(" "),_("li",[_("code",[v._v("||")]),v._v(" 有一个 true 就为 true")])]),v._v(" "),_("h3",{attrs:{id:"引用方式-代码简单实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#引用方式-代码简单实现"}},[v._v("#")]),v._v(" 引用方式（代码简单实现）")]),v._v(" "),_("p",[v._v("传值调用:将实参的值传递给形参，实参可以是变量、常量和表达式。不可以实现形参和实参间双向传递数据的效果")]),v._v(" "),_("p",[v._v("传引用(地址)调用:将实参的地址传递给形参，形参必须有地址，实参不能是常量(值)，表达式。可以实现形参和实参间双向传递数据的效果，即改变形参的值同时也改变了实参的值，")]),v._v(" "),_("h3",{attrs:{id:"编译、解释程序翻译阶段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#编译、解释程序翻译阶段"}},[v._v("#")]),v._v(" 编译、解释程序翻译阶段")]),v._v(" "),_("ul",[_("li",[v._v("编译方式 "),_("strong",[v._v("(独立)")]),v._v(" :"),_("strong",[v._v("词法分析(线性字符序列)")]),v._v("、"),_("strong",[v._v("语法分析")]),v._v("、"),_("strong",[v._v("语义分析（发现静态语法错误）")]),v._v("、"),_("em",[v._v("中间代码生成")]),v._v("、"),_("em",[v._v("代码优化")]),v._v("、"),_("strong",[v._v("目标代码生成（和机器体系结构相关")])]),v._v(" "),_("li",[v._v("解释方式:词法分析、语法分析、语义分析、（不生成目标程序，参与程序控制、慢）")]),v._v(" "),_("li",[v._v("编译器和解释器都不可省略词法分析、语法分析、语义分析且顺序不可交换，即词法分析、语法分析、语义分析是必须的。")]),v._v(" "),_("li",[v._v("编译器方式中中间代码生成和代码优化不是必要，可省略即编译器方式可以在词法分析、语法分析、语义分析阶段后直接生成目标代码")]),v._v(" "),_("li",[v._v("符号表:不断收集、记录和使用"),_("strong",[v._v("源程序中")]),v._v("一些相关符号的类型和特征等信息，并将其存入符号表中。记录源程序中各个字符的必要信息，以"),_("strong",[v._v("辅助语义")]),v._v("的正确性检查和代码生成。")])]),v._v(" "),_("hr"),v._v(" "),_("h4",{attrs:{id:"词法分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#词法分析"}},[v._v("#")]),v._v(" 词法分析")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("输入:源程序; 输出:"),_("strong",[v._v("记号流")])])]),v._v(" "),_("li",[_("p",[v._v("分析构成程序的字符及由字符"),_("strong",[v._v("按照构造规则构成的符号是否符合程序语言的规定")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("正规表达式")]),v._v("： (| = 或)(* 0个或多个)")])]),v._v(" "),_("li",[_("p",[v._v("有限自动机是"),_("strong",[v._v("词法分析")]),v._v("的一个工具，它能正确地识别正规集")]),v._v(" "),_("ul",[_("li",[v._v("确定的有限自动机(DFA):对每一个状态来说识别字符后转移的状态是"),_("strong",[v._v("唯一")]),v._v("的")]),v._v(" "),_("li",[v._v("不确定的有限自动机(NFA):对每一个状态来说识别字符后转移的状态是"),_("strong",[v._v("不确定")]),v._v("的")])])])]),v._v(" "),_("h4",{attrs:{id:"语法分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#语法分析"}},[v._v("#")]),v._v(" 语法分析")]),v._v(" "),_("ul",[_("li",[v._v("输入:"),_("strong",[v._v("记号流")]),v._v(";  输出:语法树(分析树)")]),v._v(" "),_("li",[v._v("可以发现程序中所有的语法错误 "),_("strong",[v._v("(变量是否定义,括号是否匹配)")])]),v._v(" "),_("li",[v._v("主要作用是:对各条语句的结构进行合法性分析分析程序中的句子结构是否正确")])]),v._v(" "),_("h4",{attrs:{id:"语义分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#语义分析"}},[v._v("#")]),v._v(" 语义分析")]),v._v(" "),_("ul",[_("li",[v._v("输入:语法树(分析树)")]),v._v(" "),_("li",[v._v("进行"),_("strong",[v._v("类型分析")]),v._v("和检查")]),v._v(" "),_("li",[v._v("不能发现程序中所有的语义错误,"),_("strong",[v._v("可以发现静态语义错误")]),v._v(",不能发现动态语义错误(int i = 1 / 0)，动态语义错误运行时才能发现")])]),v._v(" "),_("h4",{attrs:{id:"目标代码生成"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#目标代码生成"}},[v._v("#")]),v._v(" 目标代码生成")]),v._v(" "),_("ul",[_("li",[v._v("与具体的机器密切相关")]),v._v(" "),_("li",[v._v("寄存器的分配工作处于目标代码生成阶段")])]),v._v(" "),_("h3",{attrs:{id:"中间代码生成"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#中间代码生成"}},[v._v("#")]),v._v(" 中间代码生成")]),v._v(" "),_("ul",[_("li",[v._v("根据语义分析的输出生成中间代码")]),v._v(" "),_("li",[v._v("共同特征是"),_("strong",[v._v("与具体的机器无关")]),v._v("。")])]),v._v(" "),_("blockquote",[_("p",[v._v("常见的中间代码有:后缀式、三地址码、三元式、四元式和树(图)等形式。")])]),v._v(" "),_("h3",{attrs:{id:"上下文无关文法-语法规则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#上下文无关文法-语法规则"}},[v._v("#")]),v._v(" 上下文无关文法 （语法规则）")]),v._v(" "),_("ul",[_("li",[v._v("通常来说，小写字母是终结符号, 画图推导")])]),v._v(" "),_("h3",{attrs:{id:"中缀、后缀表达式转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#中缀、后缀表达式转换"}},[v._v("#")]),v._v(" 中缀、后缀表达式转换")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("后缀表达式，又被称为 "),_("strong",[v._v("逆波兰式")]),v._v("，用栈")])]),v._v(" "),_("li",[_("p",[v._v("原则: a * b = ab * ,不断的用这个规则整理")])])])])}),[],!1,null,null,null);_.default=a.exports}}]);